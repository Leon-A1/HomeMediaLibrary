<!DOCTYPE html>
<html>
<head>
    <title>{{ title }} - Reader</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link id="favicon" rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23007bff'><path d='M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 18H6V4h2v8l2.5-1.5L13 12V4h5v16z'/></svg>"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap">
    <style>
        :root {
            --bg-color: #000000;
            --text-color: #e0e0e0;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Roboto', sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        #reader-container {
            flex: 1;
            overflow-y: auto;
            position: relative;
            padding: 0px;
            /* Add space at the bottom so content isn't hidden behind fixed nav */
            margin-bottom: 60px;
        }

        /* Ensure the reading content is on top */
        #content {
            position: relative;
            z-index: 2;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1;
            font-size: 2em;
            padding: 10px;
            /* padding-top: 10px; */
            /* New styles to break long words */
            word-wrap: break-word;
            overflow-wrap: break-word;    
        }
        #content a{
            color: #007bff;
        }
        #content img {
            max-width: 100%;
        }

        /* New style for bookmarks */
        .bookmark {
            background-color: #007bff;
            color: white;
        }

        #toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 3;
            border-bottom: 1px solid #555;
        }

        #toolbar:hover {
            opacity: 1;
        }

        .toolbar-button {
            color: var(--text-color);
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px 10px;
            font-size: 1.2em;
        }

        .toolbar-button:hover {
            color: #007bff;
        }

        #page-info {
            color: var(--text-color);
        }

        /* Fixed bottom navigation bar for page turning */
        #bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            z-index: 4;
        }
        #bottom-nav button {
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 1.5em;
            cursor: pointer;
            padding: 0 20px;
        }
        #bottom-nav span {
            font-size: 1.2em;
        }

        #fullscreen-button {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 1.5em;
            cursor: pointer;
        }

        /* Updated styling for book title to ensure long text wraps */
        #book-title {
            font-size: 0.85em;
            padding: 0 10px;
            font-weight: bold;
            color: var(--text-color);
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: normal;
            max-width: 60vw;
            margin: 0 auto;
            text-align: center;
        }

        /* Add style for the bookmarks sidebar */
        #bookmark-sidebar {
            display: none; /* Hide sidebar by default */
            position: fixed;
            left: 0;
            top: 0; /* below the toolbar */
            width: 300px;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            color: #e0e0e0;
            overflow-y: auto;
            padding: 10px;
            z-index: 5;
            border-right: 1px solid #555;
        }
        /* Style for the close button */
        #bookmark-sidebar .close-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            color: #e0e0e0;
            font-size: 1.5em;
            cursor: pointer;
        }
        #bookmark-sidebar h3 {
            margin-top: 30px; /* leave space for the close button */
        }
        .bookmark-item {
            padding: 5px;
            margin-bottom: 5px;
            border-bottom: 1px solid #555;
            cursor: pointer;
            position: relative;
        }
        .delete-bookmark {
            position: absolute;
            right: 5px;
            top: 5px;
            color: red;
            cursor: pointer;
        }

        /* Add this CSS rule to position the bookmark toggle to the left side */
        #bookmark-toggle {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
        }
    </style>
</head>
<body>
    <div id="toolbar">
        <button class="toolbar-button" onclick="window.location.href='{{ url_for('books') }}'">
            <i class="fas fa-arrow-left"></i> Back
        </button>
        <span id="book-title">{{ title }}</span>
        <button class="toolbar-button" id="font-size-button">
            <i class="fas fa-text-height"></i>
        </button>
    </div>

    <div id="reader-container">
        <div id="content"></div>
    </div>

    <div id="bottom-nav">
        <!-- New bookmarks toggle button -->
        <button id="bookmark-toggle"><i class="fas fa-bookmark"></i></button>

        <button id="prev-page"><i class="fas fa-arrow-left"></i></button>
        <span id="current-page">Page 1</span>
        <button id="next-page"><i class="fas fa-arrow-right"></i></button>
        <!-- New fullscreen toggle button -->
        <button id="fullscreen-button"><i class="fas fa-expand"></i></button>
    </div>

    <div id="bookmark-sidebar">
        <button id="bookmark-close-button" class="close-btn"><i class="fas fa-times"></i></button>
        <h3>Bookmarks</h3>
        <div id="bookmark-list">
            <!-- Bookmark items will be populated here via JavaScript -->
        </div>
    </div>

    <script>
        let book = null;
        let currentPage = 0;
        let fontSize = 1.2;
        // Set long press threshold to 3000ms
        const longPressDuration = 3000;
        let longPressTimer = null;

        // Helper to get character offset of the selection within an element
        function getCharacterOffsetWithin(element, range) {
            let preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(element);
            preCaretRange.setEnd(range.startContainer, range.startOffset);
            return preCaretRange.toString().length;
        }

        // Helper to escape regex special characters
        function escapeRegExp(string) {
          return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        // Helper that replaces only the n-th occurrence of a word in a string
        function replaceNthOccurrence(str, word, n, replacement) {
            let index = -1;
            for (let i = 0; i < n; i++) {
                index = str.indexOf(word, index + 1);
                if (index === -1) return str;
            }
            return str.substring(0, index) + replacement + str.substring(index + word.length);
        }

        // --- Updated Code for Bookmarking on Long Tap (3 seconds) ---
        const contentDiv = document.getElementById('content');

        function addBookmark(selectedText, selectionRange) {
            // Compute the offset of the selection in the contentDiv
            let offset = getCharacterOffsetWithin(contentDiv, selectionRange);
            // Get the full plain text from contentDiv
            let contentText = contentDiv.innerText;
            // Count occurrences of the selected text BEFORE the offset
            // This gives us the occurrence index (1-based) for this bookmark.
            let occurrence = (contentText.substring(0, offset).match(new RegExp(escapeRegExp(selectedText), "g")) || []).length + 1;

            // Wrap the selected text with a span that has the "bookmark" class
            let span = document.createElement('span');
            span.className = 'bookmark';
            span.textContent = selectedText;
            
            // Replace the current selection with the new span
            selectionRange.deleteContents();
            selectionRange.insertNode(span);

            // Immediately persist the bookmark to the server, including the occurrence
            fetch('/bookmark', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    book: '{{ filename }}',
                    page: currentPage,
                    word: selectedText,
                    occurrence: occurrence
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log('Bookmark saved:', data);
                // Update both inline and sidebar bookmarks
                loadBookmarks();
                loadSidebarBookmarks();
            })
            .catch(err => console.error(err));
        }

        // For mouse events (desktop)
        contentDiv.addEventListener('mousedown', (event) => {
            longPressTimer = setTimeout(() => {
                let selection = window.getSelection();
                if (selection && selection.toString().trim().length > 0) {
                    const range = selection.getRangeAt(0);
                    addBookmark(selection.toString(), range);
                    selection.removeAllRanges();
                }
            }, longPressDuration);
        });

        contentDiv.addEventListener('mouseup', (event) => {
            clearTimeout(longPressTimer);
        });

        // For touch devices (mobile)
        contentDiv.addEventListener('touchstart', (event) => {
            longPressTimer = setTimeout(() => {
                let selection = window.getSelection();
                if (selection && selection.toString().trim().length > 0) {
                    const range = selection.getRangeAt(0);
                    addBookmark(selection.toString(), range);
                    selection.removeAllRanges();
                }
            }, longPressDuration);
        });

        contentDiv.addEventListener('touchend', (event) => {
            clearTimeout(longPressTimer);
        });
        // --- End Updated Code for Bookmarking ---

        // --- Update Load Bookmarks to Only Replace Specific Occurrence ---
        async function loadBookmarks() {
            try {
                const response = await fetch(`/api/bookmarks?book={{ filename }}&page=${currentPage}`);
                const bookmarks = await response.json();
                if (bookmarks && bookmarks.length > 0) {
                    let html = contentDiv.innerHTML;
                    // For each bookmark, replace only the nth occurrence where n is stored in bm.occurrence.
                    bookmarks.forEach(bm => {
                        // Escape special characters in the bookmark word for a literal search.
                        let escapedWord = escapeRegExp(bm.word);
                        html = replaceNthOccurrence(html, bm.word, bm.occurrence, `<span class="bookmark">${bm.word}</span>`);
                    });
                    contentDiv.innerHTML = html;
                }
            } catch (error) {
                console.error('Error loading bookmarks:', error);
            }
        }
        // --- End Load Bookmarks ---

        // Helper function to update the favicon
        function updateFavicon(url) {
            let faviconTag = document.getElementById('favicon');
            if (!faviconTag) {
                faviconTag = document.createElement('link');
                faviconTag.id = 'favicon';
                faviconTag.rel = 'icon';
                document.head.appendChild(faviconTag);
            }
            faviconTag.href = url;
        }

        // Modified loadBook function that assigns the data to the global 'book'
        async function loadBook() {
            const response = await fetch('{{ url_for("get_book_content", filename=filename) }}');
            // Assign the fetched data to the global book variable
            book = await response.json();

            // If the book data had a cover property, it would change the favicon,
            // otherwise, set it to the default. Adjust this if your API returns a cover.
            if (book.cover && book.cover.trim() !== "") {
                updateFavicon(book.cover);
            } else {
                updateFavicon("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23007bff'><path d='M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 18H6V4h2v8l2.5-1.5L13 12V4h5v16z'/></svg>");
            }

            // Get the last viewed page based on bookmarks.
            try {
                const res = await fetch(`/api/bookmarks/last?book={{ filename }}`);
                const data = await res.json();
                if (data && typeof data.page === 'number' && data.page < book.pages.length) {
                    currentPage = data.page;
                }
            } catch (err) {
                console.error(err);
            }
            displayCurrentPage();
        }

        function displayCurrentPage() {
            if (book && book.pages) {
                document.getElementById('content').innerHTML = book.pages[currentPage];
                document.getElementById('current-page').textContent = `Page  ${currentPage + 1} / ${book.pages.length}`;
                loadBookmarks();        // reload inline bookmarks
                loadSidebarBookmarks(); // load bookmarks in the sidebar
                document.getElementById('content').scrollIntoView({ behavior: 'smooth' });
            }
        }

        // Bottom navigation buttons
        document.getElementById('prev-page').addEventListener('click', () => {
            if (currentPage > 0) {
                currentPage--;
                displayCurrentPage();
            }
        });

        document.getElementById('next-page').addEventListener('click', () => {
            if (book && currentPage < book.pages.length - 1) {
                currentPage++;
                displayCurrentPage();
            }
        });

        document.getElementById('font-size-button').addEventListener('click', () => {
            fontSize = fontSize === 1.2 ? 1.5 : fontSize === 1.5 ? 1.8 : 1.2;
            document.getElementById('content').style.fontSize = `${fontSize}em`;
        });

        // New event listener for the fullscreen button
        document.getElementById('fullscreen-button').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen()
                .then(() => {
                    document.getElementById('fullscreen-button').innerHTML = '<i class="fas fa-compress"></i>';
                    document.getElementById('reader-container').style.marginBottom = '55px';
                })
                .catch(err => console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`));
            } else {
                document.exitFullscreen()
                .then(() => {
                    document.getElementById('fullscreen-button').innerHTML = '<i class="fas fa-expand"></i>';
                    document.getElementById('reader-container').style.marginBottom = '60px';
                })
                .catch(err => console.error(`Error attempting to disable full-screen mode: ${err.message} (${err.name})`));
            }
        });

        // Function to load all bookmarks for the current book into the sidebar
        async function loadSidebarBookmarks() {
            try {
                // Note: we are no longer filtering by currentPage here.
                const response = await fetch(`/api/bookmarks?book={{ filename }}`);
                const bookmarks = await response.json();
                const bookmarkList = document.getElementById('bookmark-list');
                bookmarkList.innerHTML = '';
                // Optionally, sort bookmarks by page number for easier navigation
                bookmarks.sort((a, b) => parseInt(a.page) - parseInt(b.page));
                bookmarks.forEach(bm => {
                    const div = document.createElement('div');
                    div.className = 'bookmark-item';
                    div.innerHTML = `Page: ${bm.page} | Word: ${bm.word} (occurrence: ${bm.occurrence})
                      <span class="delete-bookmark" data-word="${bm.word}" data-occurrence="${bm.occurrence}" data-page="${bm.page}">&times;</span>`;
                    // Clicking anywhere on the item (other than delete) jumps to that page
                    div.addEventListener('click', () => {
                        currentPage = bm.page; // Jump to the bookmarked page
                        displayCurrentPage();
                    });
                    bookmarkList.appendChild(div);
                });
            } catch (err) {
                console.error('Error loading sidebar bookmarks:', err);
            }
        }

        // Add an event listener on the sidebar list to handle bookmark deletion
        document.getElementById('bookmark-list').addEventListener('click', async (event) => {
            if (event.target.classList.contains('delete-bookmark')) {
                event.stopPropagation();
                const word = event.target.getAttribute('data-word');
                const occurrence = parseInt(event.target.getAttribute('data-occurrence'));
                const page = parseInt(event.target.getAttribute('data-page'));
                try {
                    const response = await fetch('/bookmark/delete', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            book: '{{ filename }}',
                            page: page,
                            word: word,
                            occurrence: occurrence
                        })
                    });
                    const data = await response.json();
                    if (data.success) {
                        // Reload the sidebar and the inline bookmarks after deletion
                        loadSidebarBookmarks();
                        loadBookmarks();
                    } else {
                        console.error('Error deleting bookmark:', data.message);
                    }
                } catch (err) {
                    console.error('Error:', err);
                }
            }
        });

        // Toggle the bookmarks sidebar visibility using the bottom navbar button.
        const bookmarkToggleButton = document.getElementById('bookmark-toggle');
        const bookmarkSidebar = document.getElementById('bookmark-sidebar');

        bookmarkToggleButton.addEventListener('click', () => {
            if (bookmarkSidebar.style.display === 'none' || bookmarkSidebar.style.display === '') {
                bookmarkSidebar.style.display = 'block';
            } else {
                bookmarkSidebar.style.display = 'none';
            }
        });

        // Add event listener for the close button in the sidebar.
        const bookmarkCloseButton = document.getElementById('bookmark-close-button');
        bookmarkCloseButton.addEventListener('click', () => {
            bookmarkSidebar.style.display = 'none';
        });

        // Add an event listener to close the bookmarks sidebar when clicking outside of it
        document.addEventListener('click', function(event) {
            const bookmarkSidebar = document.getElementById('bookmark-sidebar');
            const bookmarkToggleButton = document.getElementById('bookmark-toggle');

            // If the sidebar is visible and the click target is not within the sidebar or on the toggle button, close it.
            if (bookmarkSidebar.style.display === 'block' &&
                !bookmarkSidebar.contains(event.target) &&
                event.target !== bookmarkToggleButton &&
                !bookmarkToggleButton.contains(event.target)
            ) {
                bookmarkSidebar.style.display = 'none';
            }
        });

        loadBook();
    </script>
</body>
</html> 