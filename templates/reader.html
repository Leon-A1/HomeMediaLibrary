<!DOCTYPE html>
<html>
<head>
    <title>{{ title }} - Reader</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap">
    <style>
        :root {
            --bg-color: #000000;
            --text-color: #e0e0e0;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Roboto', sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        #reader-container {
            flex: 1;
            overflow-y: auto;
            position: relative;
            padding: 0px;
            /* Add space at the bottom so content isn't hidden behind fixed nav */
            margin-bottom: 160px;
        }

        /* Ensure the reading content is on top */
        #content {
            position: relative;
            z-index: 2;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1;
            font-size: 2em;
            padding: 10px;
            padding-top: 20px;
            /* New styles to break long words */
            word-wrap: break-word;
            overflow-wrap: break-word;    
        }
        #content img {
            max-width: 100%;
        }

        /* New style for bookmarks */
        .bookmark {
            background-color: #007bff;
            color: white;
        }

        #toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 3;
        }

        #toolbar:hover {
            opacity: 1;
        }

        .toolbar-button {
            color: var(--text-color);
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px 10px;
            font-size: 1.2em;
        }

        .toolbar-button:hover {
            color: #007bff;
        }

        #page-info {
            color: var(--text-color);
        }

        /* Fixed bottom navigation bar for page turning */
        #bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            z-index: 4;
        }
        #bottom-nav button {
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 1.5em;
            cursor: pointer;
            padding: 0 20px;
        }
        #bottom-nav span {
            font-size: 1.2em;
        }

        #fullscreen-button {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 1.5em;
            cursor: pointer;
        }

        /* Updated styling for book title to ensure long text wraps */
        #book-title {
            font-size: 0.85em;
            padding: 0 10px;
            font-weight: bold;
            color: var(--text-color);
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: normal;
            max-width: 60vw;
        }
    </style>
</head>
<body>
    <div id="toolbar">
        <button class="toolbar-button" onclick="window.location.href='{{ url_for('books') }}'">
            <i class="fas fa-arrow-left"></i> Back
        </button>
        <span id="book-title">{{ title }}</span>
        <button class="toolbar-button" id="font-size-button">
            <i class="fas fa-text-height"></i>
        </button>
    </div>

    <div id="reader-container">
        <div id="content"></div>
    </div>

    <div id="bottom-nav">
        <button id="prev-page"><i class="fas fa-arrow-left"></i></button>
        <span id="current-page">Page 1</span>
        <button id="next-page"><i class="fas fa-arrow-right"></i></button>
        <!-- New fullscreen toggle button -->
        <button id="fullscreen-button"><i class="fas fa-expand"></i></button>
    </div>

    <script>
        let book = null;
        let currentPage = 0;
        let fontSize = 1.2;
        // Set long press threshold to 3000ms
        const longPressDuration = 3000;
        let longPressTimer = null;

        // Helper to get character offset of the selection within an element
        function getCharacterOffsetWithin(element, range) {
            let preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(element);
            preCaretRange.setEnd(range.startContainer, range.startOffset);
            return preCaretRange.toString().length;
        }

        // Helper to escape regex special characters
        function escapeRegExp(string) {
          return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        // Helper that replaces only the n-th occurrence of a word in a string
        function replaceNthOccurrence(str, word, n, replacement) {
            let index = -1;
            for (let i = 0; i < n; i++) {
                index = str.indexOf(word, index + 1);
                if (index === -1) return str;
            }
            return str.substring(0, index) + replacement + str.substring(index + word.length);
        }

        // --- Updated Code for Bookmarking on Long Tap (3 seconds) ---
        const contentDiv = document.getElementById('content');

        function addBookmark(selectedText, selectionRange) {
            // Compute the offset of the selection in the contentDiv
            let offset = getCharacterOffsetWithin(contentDiv, selectionRange);
            // Get the full plain text from contentDiv
            let contentText = contentDiv.innerText;
            // Count occurrences of the selected text BEFORE the offset
            // This gives us the occurrence index (1-based) for this bookmark.
            let occurrence = (contentText.substring(0, offset).match(new RegExp(escapeRegExp(selectedText), "g")) || []).length + 1;

            // Wrap the selected text with a span that has the "bookmark" class
            let span = document.createElement('span');
            span.className = 'bookmark';
            span.textContent = selectedText;
            
            // Replace the current selection with the new span
            selectionRange.deleteContents();
            selectionRange.insertNode(span);

            // Immediately persist the bookmark to the server, including the occurrence
            fetch('/bookmark', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    book: '{{ filename }}',
                    page: currentPage,
                    word: selectedText,
                    occurrence: occurrence
                })
            })
            .then(response => response.json())
            .then(data => { console.log('Bookmark saved:', data); })
            .catch(err => console.error(err));
        }

        // For mouse events (desktop)
        contentDiv.addEventListener('mousedown', (event) => {
            longPressTimer = setTimeout(() => {
                let selection = window.getSelection();
                if (selection && selection.toString().trim().length > 0) {
                    const range = selection.getRangeAt(0);
                    addBookmark(selection.toString(), range);
                    selection.removeAllRanges();
                }
            }, longPressDuration);
        });

        contentDiv.addEventListener('mouseup', (event) => {
            clearTimeout(longPressTimer);
        });

        // For touch devices (mobile)
        contentDiv.addEventListener('touchstart', (event) => {
            longPressTimer = setTimeout(() => {
                let selection = window.getSelection();
                if (selection && selection.toString().trim().length > 0) {
                    const range = selection.getRangeAt(0);
                    addBookmark(selection.toString(), range);
                    selection.removeAllRanges();
                }
            }, longPressDuration);
        });

        contentDiv.addEventListener('touchend', (event) => {
            clearTimeout(longPressTimer);
        });
        // --- End Updated Code for Bookmarking ---

        // --- Update Load Bookmarks to Only Replace Specific Occurrence ---
        async function loadBookmarks() {
            try {
                const response = await fetch(`/api/bookmarks?book={{ filename }}&page=${currentPage}`);
                const bookmarks = await response.json();
                if (bookmarks && bookmarks.length > 0) {
                    let html = contentDiv.innerHTML;
                    // For each bookmark, replace only the nth occurrence where n is stored in bm.occurrence.
                    bookmarks.forEach(bm => {
                        // Escape special characters in the bookmark word for a literal search.
                        let escapedWord = escapeRegExp(bm.word);
                        html = replaceNthOccurrence(html, bm.word, bm.occurrence, `<span class="bookmark">${bm.word}</span>`);
                    });
                    contentDiv.innerHTML = html;
                }
            } catch (error) {
                console.error('Error loading bookmarks:', error);
            }
        }
        // --- End Load Bookmarks ---

        // --- Existing Code for Loading the Book and Page Navigation ---
        async function loadBook() {
            const response = await fetch('{{ url_for("get_book_content", filename=filename) }}');
            book = await response.json();
            try {
                const res = await fetch(`/api/bookmarks/last?book={{ filename }}`);
                const data = await res.json();
                // Only update currentPage if data.page is valid and within range
                if (data && typeof data.page === 'number' && data.page < book.pages.length) {
                    currentPage = data.page;
                }
            } catch (err) {
                console.error(err);
            }
            displayCurrentPage();
        }

        function displayCurrentPage() {
            if (book && book.pages) {
                // Set the content for the current page
                document.getElementById('content').innerHTML = book.pages[currentPage];
                // Update the current page information to include the total pages
                document.getElementById('current-page').textContent = `Page  ${currentPage + 1} / ${book.pages.length}`;
                // Re-highlight any bookmarks for this page
                loadBookmarks();
                // Scroll to the content smoothly
                document.getElementById('content').scrollIntoView({ behavior: 'smooth' });
            }
        }

        // Bottom navigation buttons
        document.getElementById('prev-page').addEventListener('click', () => {
            if (currentPage > 0) {
                currentPage--;
                displayCurrentPage();
            }
        });

        document.getElementById('next-page').addEventListener('click', () => {
            if (book && currentPage < book.pages.length - 1) {
                currentPage++;
                displayCurrentPage();
            }
        });

        document.getElementById('font-size-button').addEventListener('click', () => {
            fontSize = fontSize === 1.2 ? 1.5 : fontSize === 1.5 ? 1.8 : 1.2;
            document.getElementById('content').style.fontSize = `${fontSize}em`;
        });

        // New event listener for the fullscreen button
        document.getElementById('fullscreen-button').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen()
                .then(() => {
                    document.getElementById('fullscreen-button').innerHTML = '<i class="fas fa-compress"></i>';
                    document.getElementById('reader-container').style.marginBottom = '55px';
                })
                .catch(err => console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`));
            } else {
                document.exitFullscreen()
                .then(() => {
                    document.getElementById('fullscreen-button').innerHTML = '<i class="fas fa-expand"></i>';
                    document.getElementById('reader-container').style.marginBottom = '160px';
                })
                .catch(err => console.error(`Error attempting to disable full-screen mode: ${err.message} (${err.name})`));
            }
        });

        loadBook();
    </script>
</body>
</html> 